//#![feature(hashmap_hasher)] // requires rust-nightly

#[macro_use]
extern crate log;
extern crate time;
extern crate crypto;
extern crate argparse;
extern crate rustc_serialize;
//extern crate twox_hash; // requires rust-nightly
extern crate byteorder;
extern crate rust_base58;


#[macro_use]
pub mod errors;
pub mod blockchain;
pub mod common;
#[macro_use]
pub mod callbacks;

use std::fs;
use std::path::{Path, PathBuf};
use std::io::{ErrorKind};
use std::sync::mpsc;
use std::boxed::Box;

use argparse::{ArgumentParser, Store, IncrBy, StoreTrue, List, Print};
use log::LogLevelFilter;

use blockchain::parser::chain;
use blockchain::parser::types::{self, CoinType, Bitcoin};
use blockchain::utils;
use blockchain::utils::blkfile::BlkFile;
use blockchain::parser::{ParseMode, BlockchainParser};
use common::logger::SimpleLogger;
use errors::{OpError, OpErrorKind, OpResult};
use callbacks::Callback;
use callbacks::stats::SimpleStats;
use callbacks::csvdump::CsvDump;


/// Holds all available user arguments
pub struct ParserOptions {
    callback: Box<Callback>,        /* Name of the callback which gets executed for each block. (See callbacks/mod.rs)                      */
    coin_type: CoinType,            /* Holds the name of the coin we want to parse                                                          */
    verify_merkle_root: bool,       /* Enable this if you want to check the merkle root of each block. Aborts if something is fishy.        */
    thread_count: u8,               /* Number of core threads. The callback gets sequentially called!                                       */
    resume: bool,                   /* Resumes from latest known hash in chain.json.                                                        */
    new: bool,                      /* Forces new scan                                                                                      */
    blockchain_dir: PathBuf,        /* Path to directory where blk.dat files are stored                                                     */
    chain_storage_path: PathBuf,    /* Path to the longest-chain.json generated by initial header scan                                      */
    worker_backlog: usize,          /* Maximum backlog for each thread. If the backlog is full the worker waits until there is some space.  */
                                    /* Usually this happens if the callback implementation is too slow or if we reached the I/O capabilites */
    verbosity: u8                   /* Verbosity level, 0 = Error, 1 = Info, 2 = Debug, 3+ = Trace                                          */
}

fn main() {

    // Init user args
    let mut options = match parse_args() {
        Ok(o) => o,
        Err(desc) => {
            // Init logger to print outstanding error message
            SimpleLogger::init(LogLevelFilter::Debug).unwrap();
            error!(target: "main", "{}", desc);
            return;
        }
    };

    // Apply log filter based on verbosity
    let log_filter = match options.verbosity {
        0 => LogLevelFilter::Error,
        1 => LogLevelFilter::Info,
        2 => LogLevelFilter::Debug,
        _ => LogLevelFilter::Trace
    };
    SimpleLogger::init(log_filter).expect("Unable to initialize logger!");
    info!(target: "main", "Starting rusty-blockparser v{} ...", env!("CARGO_PKG_VERSION"));
    debug!(target: "main", "Using LogLevel {}", log_filter);
    if options.new {
        fs::remove_file(options.chain_storage_path.clone()).ok();
    }

    // Two iterations possible. First one could be ParseMode::HeaderOnly
    let mut resume = options.resume;
    let iterations = 2;
    for i in 0..iterations {
        // Load chain file into memory
        let chain_file = match load_chain_file(&options.chain_storage_path) {
            Ok(f) => f,
            Err(desc) => {
                error!(target: "main", "Can't load chain storage. {}", desc);
                return;
            }
        };

        // Determine ParseMode based on existing chain file
        let parse_mode = match chain_file.len() == 0 || resume {
            true => ParseMode::HeaderOnly,
            false => ParseMode::FullData
        };

        // Determine starting location based on previous scans.
        let start_blk_idx = match parse_mode {
            ParseMode::HeaderOnly => 0,
            ParseMode::FullData => chain_file.latest_blk_idx
        };

        // Load blk files from blockchain dir
        let blk_files = match BlkFile::from_path(options.blockchain_dir.clone(), start_blk_idx) {
            Ok(files) => files,
            Err(e) => {
                error!("Cannot load blockchain from: '{}'. {}", &options.blockchain_dir.display(), e);
                return;
            }
        };

        if parse_mode == ParseMode::FullData && chain_file.remaining() == 0 {
            info!("All {} known blocks are processed! Try again with `--resume` to scan for new blocks, or force a full rescan with `--new`",
                chain_file.get_cur_height());
            return;
        }

        {   // Start parser
            let (tx, rx) = mpsc::sync_channel(options.worker_backlog);
            let mut parser = BlockchainParser::new(
                &mut options,
                parse_mode.clone(),
                blk_files,
                chain_file);

            // Start threads
            if let Some(err) = parser.start_worker(tx).err() {
                error!(target: "parser", "{}", err);
            }
            // Dispatch thread messages
            if let Some(err) = parser.dispatch(rx).err() {
                error!(target: "dispatch", "{}", err);
                return;
            }
        }

        info!(target: "main", "Iteration {} finished.", i + 1);

        // If last mode was FullData we can break
        if parse_mode == ParseMode::FullData {
            break;
        }
        // Reset resume mode after first iteration
        if resume {
            resume = false;
        }
    }
    info!(target: "main", "Fin.");
}

/// Initializes all required data
fn load_chain_file(path: &Path) -> OpResult<chain::ChainStorage> {
    let err = match chain::ChainStorage::load(path.clone()) {
        Ok(storage) => return Ok(storage),
        Err(e) => e
    };
    match err.kind {
        // If there is no storage, create a new one
        OpErrorKind::IoError(err) => {
            match err.kind() {
                ErrorKind::NotFound => return Ok(chain::ChainStorage::default()),
                _ => return Err(OpError::from(err)),
            }
        }
        kind @ _ => return Err(OpError::new(kind))
    }
}

/// Parses args or panics if some requirements are not met.
fn parse_args() -> OpResult<ParserOptions> {

    let mut coin_type = CoinType::from(Bitcoin);
    let mut callback_name = String::from("csvdump");
    let mut callback_args = vec!();
    let mut verify_merkle_root = false;
    let mut thread_count = 2;
    let mut resume = false;
    let mut new = false;
    let mut blockchain_dir = String::from("");
    let mut chain_storage_path = String::from("chain.json");
    let mut worker_backlog = 100;
    let mut verbosity = 1;

    let desc_str = "Multithreaded Blockchain Parser written in Rust";
    let verify_merkle_str = format!("Verify merkle root (default: {})", &verify_merkle_root);
    let thread_count_str = format!("Thread count (default: {})", &thread_count);
    let blockchain_dir_str = "Set blockchain directory which contains blk.dat files (default: ~/.bitcoin/blocks)";
    let chain_file_str = format!("Specify path to chain storage. This is just a internal state file (default: {})", &chain_storage_path);
    let max_work_blog_str = format!("Set maximum worker backlog (default: {})", &worker_backlog);
    let verbosity_str = format!("Increases verbosity level. Error=0, Info=1, Debug=2, Trace=3 (default: {})", verbosity);
    {
        let mut ap = ArgumentParser::new();
        ap.set_description(&desc_str);
        ap.add_option(&["--list-coins"], Print(types::list_coins(&desc_str)), "Lists all implemented coins");
        ap.add_option(&["--list-callbacks"], Print(callbacks::list_callbacks(&desc_str)), "Lists all available callbacks");
        ap.refer(&mut coin_type).add_option(&["-c", "--coin"], Store, "Specify blockchain coin (default: bitcoin)").metavar("COINNAME");
        ap.refer(&mut blockchain_dir).add_option(&["-d", "--blockchain-dir"], Store, &blockchain_dir_str).metavar("PATH");
        ap.refer(&mut verify_merkle_root).add_option(&["--verify-merkle-root"], Store, &verify_merkle_str).metavar("BOOL");
        ap.refer(&mut thread_count).add_option(&["-t", "--threads"], Store, &thread_count_str).metavar("COUNT");
        ap.refer(&mut resume).add_option(&["-r", "--resume"], StoreTrue, "Resume from latest known block");
        ap.refer(&mut new).add_option(&["--new"], StoreTrue, "Force complete rescan");
        ap.refer(&mut chain_storage_path).add_option(&["-s", "--chain-storage"], Store, &chain_file_str).metavar("PATH");
        ap.refer(&mut worker_backlog).add_option(&["--backlog"], Store, &max_work_blog_str).metavar("COUNT");
        ap.refer(&mut verbosity).add_option(&["-v", "--verbose"], IncrBy(1), &verbosity_str);
        ap.add_option(&["--version"], Print(env!("CARGO_PKG_VERSION").to_string()), "Show version");

        ap.refer(&mut callback_name).required().add_argument(&"callback", Store,
                "Set a callback to execute. See `--list-callbacks`");
        ap.refer(&mut callback_args).required().add_argument(&"arguments", List,
                "All following arguments are consumed by this callback.");
        ap.parse_args_or_exit();
    }

    if new && resume {
        return Err(OpError::new(OpErrorKind::InvalidArgsError)
            .join_msg("Cannot apply `--new` and `--resume` at the same time!"));
    }

    // If blockchain path is not provided set default locations
    let blockchain_path = match blockchain_dir.is_empty() {
        true => utils::get_absolute_blockchain_dir(&coin_type),
        false => PathBuf::from(blockchain_dir)
    };

    callback_args.insert(0, format!("Callback {}", callback_name));
    // Add custom callbacks here. Also add them to list_callbacks()
    let callback: Box<Callback> = match callback_name.as_ref() {
        "simplestats"   => Box::new(try!(SimpleStats::parse_args(callback_args))),
        "csvdump"       => Box::new(try!(CsvDump::parse_args(callback_args))),
        cb @ _          => {
            return Err(OpError::new(OpErrorKind::InvalidArgsError)
                .join_msg(&format!("Callback `{}` not found. Try `--list-callbacks`", &cb)));
        }
    };
    Ok(ParserOptions {
        coin_type: coin_type,
        callback: callback,
        verify_merkle_root: verify_merkle_root,
        thread_count: thread_count,
        resume: resume,
        new: new,
        blockchain_dir: blockchain_path,
        chain_storage_path: PathBuf::from(chain_storage_path),
        worker_backlog: worker_backlog,
        verbosity: verbosity
    })
}
